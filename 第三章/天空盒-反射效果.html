<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>立方体贴图-天空盒</title>
    <script src="../lib/webgl-utils.js"></script>
    <script src="../lib/webgl-debug.js"></script>
    <script src="../lib/cuon-utils.js"></script>
    <script src="../lib/cuon-matrix.js"></script>
    <!--<script src="//cdn.bootcss.com/gl-matrix/2.3.2/gl-matrix-min.js"></script>-->
    <script type="text/javascript">
      //天空盒着色器
      var skybox_vs = `
        attribute vec3 a_position;
        attribute vec3 a_color;
        uniform mat4 u_matrix;
        varying vec3 v_color;
        varying vec3 v_texCoord; // 天空盒纹理坐标
        void main() {
        //用xyww做颜色取值，是为了将天空盒的z深度值永远置为最大1
        gl_Position = (u_matrix * vec4(a_position, 1.0)).xyww;
        v_color = a_color;
        // 因为天空盒的中心在原点，所以纹理坐标就是顶点坐标
        v_texCoord = a_position;
      }`;
     //片元着色器
      var skybox_fs =
       `precision mediump float;
        uniform samplerCube u_sampler; // 采样器
        varying vec3 v_color;
        varying vec3 v_texCoord;
        void main(){
        vec4 baseColor = vec4(v_color, 1.0); // 本来的颜色
        vec4 texture = textureCube(u_sampler, v_texCoord); // 纹理颜色
        gl_FragColor = baseColor * texture;
        }`;
        //场景中的小箱子的着色器
       var cube_vs =
        `attribute vec4 a_position;
        attribute vec4 a_normal; // 顶点法线
        uniform mat4 u_matrix; // 模型视图投影矩阵
        uniform mat4 u_mMatrix; // 模型矩阵
        uniform mat4 u_normalMatrix; // 模型矩阵的逆转置矩阵
        varying vec3 v_normal;
        varying vec3 v_position;
        void main(){
            gl_Position = u_matrix * a_position;
            // 因顶点位置变换，将正确的顶点位置传给片元着色器
            v_position = vec3( u_mMatrix * a_position );

            // 因顶点位置变换，将正确的法向量传给片元着色器
            v_normal = normalize( vec3( u_normalMatrix * a_normal ) );
        }`;

       var cube_fs =
       `precision mediump float;
        uniform samplerCube u_sampler; // 采样器
        uniform vec3 u_eyePosition; // 相机的位置向量
        varying vec3 v_normal;
        varying vec3 v_position;
        void main(){
            // 计算视线向量eye
            vec3 eye = normalize(v_position - u_eyePosition);
            // 计算反射向量，来作为采样器的纹理坐标
            vec3 texCoord = reflect( eye, v_normal );
            gl_FragColor = textureCube( u_sampler, texCoord );
       }`;

       var canvas, gl, skybox_program, cube_program;
       var OFF_SCREEN_WIDTH, OFF_SCREEN_HEIGHT, cubeTextureTargets;
       var sky, cube, fbo, skyTexture, pvMatrix, t, eyePosition;
       function main() {
           canvas = document.getElementById('myCanvas'); // canvas
           gl = canvas.getContext('webgl'); // 上下文

           skybox_program = createProgram(gl, skybox_vs, skybox_fs);

           skybox_program.a_position = gl.getAttribLocation(skybox_program, 'a_position');
           skybox_program.a_color = gl.getAttribLocation(skybox_program, 'a_color');
           skybox_program.u_matrix = gl.getUniformLocation(skybox_program, 'u_matrix');
           // 立方体着色器程序对象
           cube_program = createProgram(gl, cube_vs, cube_fs);
           // 着色器变量地址存到程序对象的属性中
           cube_program.a_position = gl.getAttribLocation(cube_program, 'a_position');
           cube_program.a_normal = gl.getAttribLocation(cube_program, 'a_normal');
           cube_program.u_matrix = gl.getUniformLocation(cube_program, 'u_matrix');
           cube_program.u_mMatrix = gl.getUniformLocation(cube_program, 'u_mMatrix');
           cube_program.u_normalMatrix = gl.getUniformLocation(cube_program, 'u_normalMatrix');
           cube_program.u_eyePosition = gl.getUniformLocation(cube_program, 'u_eyePosition');
           cube_program.u_sampler = gl.getUniformLocation(cube_program, 'u_sampler');
           // 离屏绘制尺寸
           OFF_SCREEN_WIDTH = 512;
           OFF_SCREEN_HEIGHT = 512;
           // 立方贴图六个面的目标，这个是webgl为立方体贴图专门提供的特殊纹理目标
           cubeTextureTargets = [
               gl.TEXTURE_CUBE_MAP_POSITIVE_X,
               gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
               gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
               gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
               gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
               gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
           ];

           // 初始化天空盒buffer
           sky = initCubeBuffer();

           // 初始化立方体buffer
           cube = initCubeBuffer();

           // 初始化帧缓冲区
           fbo = initFBO();

           // 初始化天空盒纹理
           skyTexture = initSkyTexture();

           // 相机的位置
           eyePosition = new Float32Array([7.0, 0.0,10.0]);

           // 视图投影矩阵
           pvMatrix = createPvMatrix({ eye: eyePosition });
           //改用比较熟悉的矩阵

           //声明一个角度数组，存放x,y方向上的角度
           var currentAngle = [0.0, 0.0];
           // 注册鼠标事件，可以旋转角度
           initEventHandlers(canvas, currentAngle);
           // 渲染循环
           t = 0;
           var loop = function () {
               drawFBO(currentAngle); // 在帧缓冲区中绘制天空盒
               draw(currentAngle); // 常规绘制天空盒和立方体
               t++;
               window.requestAnimationFrame(loop);
           }
           loop();
       }


       function draw(currentAngle) {
           gl.viewport(0, 0, canvas.width, canvas.height);
           gl.clearColor(0.0, 0.0, 0.0, 1.0);
           gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
           gl.enable(gl.DEPTH_TEST);
           //将深度测试改为LEQUAL,是为了不绘制场景中被其他物体挡住的部分，因为理论上，天空盒场景中的所有物体的深度值都应该小于天空盒的深度值，
           //即在天空盒的前面
           gl.depthFunc(gl.LEQUAL);
           drawSky(currentAngle);
           drawCube(currentAngle);
       }

       function drawFBO(currentAngle) {
           gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

           gl.viewport(0, 0, OFF_SCREEN_WIDTH, OFF_SCREEN_HEIGHT);
           gl.clearColor(0.0, 0.0, 0.0, 1.0);
           //禁用深度写入，确保天空盒永远在其他物体后面
           gl.disable(gl.DEPTH_TEST);

           gl.useProgram(skybox_program);

           cubeTextureTargets.forEach(function (target, index) {
               gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, fbo.texture, null);

               var eye = new Float32Array([0.0, 0.0, 0.0]);
               var up = new Float32Array([0.0, 0.0, 0.0]);
               var center = new Float32Array([0.0, 0.0, 0.0]);

               switch (index) {
                   case 0:
                       // 看右
                       up[1] = -1.0;
                       center[0] = 1.0;
                       break;
                   case 1:
                       // 看左
                       up[1] = -1.0;
                       center[0] = -1.0;
                       break;
                   case 2:
                       // 看上
                       up[2] = -1.0;
                       center[1] = 1.0;
                       break;
                   case 3:
                       // 看下
                       up[2] = -1.0;
                       center[1] = -1.0;
                       break;
                   case 4:
                       // 看前
                       up[1] = -1.0;
                       center[2] = 1.0;
                       break;
                   case 5:
                       // 看后
                       up[1] = -1.0;
                       center[2] = -1.0;
                       break;
               }

               // FBO用自己的视图投影矩阵
               var pvMatrixFBO = createPvMatrix({
                   eye: eye,
                   center: center,
                   up: up
               });

               drawSky(currentAngle, pvMatrixFBO);
           });

           gl.bindFramebuffer(gl.FRAMEBUFFER, null);
       }

       function drawCube() {
           gl.enable(gl.CULL_FACE);
           gl.cullFace(gl.BACK);

           gl.useProgram(cube_program);

           gl.bindBuffer(gl.ARRAY_BUFFER, cube.vBuffer);
           gl.vertexAttribPointer(cube_program.a_position, 3, gl.FLOAT, false, 0, 0);
           gl.enableVertexAttribArray(cube_program.a_position);

           gl.bindBuffer(gl.ARRAY_BUFFER, cube.nBuffer);
           gl.vertexAttribPointer(cube_program.a_normal, 3, gl.FLOAT, false, 0, 0);
           gl.enableVertexAttribArray(cube_program.a_normal);

           //矩阵计算
           var mMatrix = new Matrix4();
           var pvmMatrix = new Matrix4();
           pvmMatrix.set(pvMatrix);
           mMatrix.translate(0.0, -2.5,0.0);
           mMatrix.scale(0.1, 0.1, 0.1);
           pvmMatrix.multiply(mMatrix);
           gl.uniformMatrix4fv(cube_program.u_matrix, false, pvmMatrix.elements);
           gl.uniformMatrix4fv(cube_program.u_mMatrix, false, mMatrix.elements);

           var nMatrix = new Matrix4();
           nMatrix.setInverseOf(mMatrix);
           nMatrix.transpose();
           gl.uniformMatrix4fv(cube_program.u_normalMatrix, false, nMatrix.elements);

           gl.uniform3fv(cube_program.u_eyePosition, eyePosition);

           gl.activeTexture(gl.TEXTURE0);
           gl.bindTexture(gl.TEXTURE_CUBE_MAP, fbo.texture);

           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.iBuffer);
           gl.drawElements(gl.TRIANGLES, cube.indexCount, gl.UNSIGNED_BYTE, 0);
       }

       function drawSky(currentAngle, pvMatrixFBO) {

           gl.enable(gl.CULL_FACE);
           gl.cullFace(gl.FRONT);

           var _pvMatrix = pvMatrixFBO ? pvMatrixFBO : pvMatrix;

           gl.useProgram(skybox_program);

           gl.bindBuffer(gl.ARRAY_BUFFER, sky.vBuffer);
           gl.vertexAttribPointer(skybox_program.a_position, 3, gl.FLOAT, false, 0, 0);
           gl.enableVertexAttribArray(skybox_program.a_position);

           gl.bindBuffer(gl.ARRAY_BUFFER, sky.cBuffer);
           gl.vertexAttribPointer(skybox_program.a_color, 3, gl.FLOAT, false, 0, 0);
           gl.enableVertexAttribArray(skybox_program.a_color);

           gl.activeTexture(gl.TEXTURE0);
           gl.bindTexture(gl.TEXTURE_CUBE_MAP, skyTexture);

           var mMatrix = new Matrix4();
           var pvmMatrix = new Matrix4();
           pvmMatrix.set(_pvMatrix);
           mMatrix.rotate(currentAngle[0], 1, 0, 0);
           mMatrix.rotate(currentAngle[1], 0, 1, 0);
           pvmMatrix.multiply(mMatrix);
           gl.uniformMatrix4fv(skybox_program.u_matrix, false, pvmMatrix.elements);
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sky.iBuffer);
           gl.drawElements(gl.TRIANGLES, sky.indexCount, gl.UNSIGNED_BYTE, 0);
       }

       function initSkyTexture() {
           var texture = gl.createTexture();
           loadImages([
               '../images/right.jpg',
               '../images/left.jpg',
               '../images/top.jpg',
               '../images/bottom.jpg',
               '../images/front.jpg',
               '../images/back.jpg'
           ], function (images) {
               gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
               gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
               gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
               gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
               gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
               //TEXTURE_WRAP_R在webgl中没有，另外设置成CLAMP_TO_EDGE是为了使边界无缝对接上
               //gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
               cubeTextureTargets.forEach(function (target, index) {
                   gl.texImage2D(target, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images[index]);
               });
               gl.useProgram(skybox_program);
               gl.uniform1i(skybox_program.u_sampler, 0);
               gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
           });
           return texture;
       }

       function initFBO() {
           var frameBuffer = gl.createFramebuffer();

           var texture = gl.createTexture();
           //TEXTURE_CUBE_MAP为立方体纹理贴图目标
           gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
           cubeTextureTargets.forEach(function (target) {
               gl.texImage2D(target, 0, gl.RGBA, OFF_SCREEN_WIDTH, OFF_SCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
           });
           gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
           frameBuffer.texture = texture;

           gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
           gl.bindFramebuffer(gl.FRAMEBUFFER, null);

           return frameBuffer;
       }

        //创建视图矩阵
       function createPvMatrix(params) {
           var params = params || {};
           var eye = params.eye || new Float32Array([0.0, 0.0, 10.0]);
           var center = params.center || new Float32Array([0.0, 0.0, 0.0]);
           var up = params.up || new Float32Array([0.0, 1.0, 0.0]);

           var pvMatrix = new Matrix4();
           pvMatrix.setPerspective(70.0, canvas.width / canvas.height, 0.1, 2000.0);
           pvMatrix.lookAt(eye[0], eye[1], eye[2], center[0], center[1], center[2], up[0], up[1], up[2]);

           return pvMatrix;
       }

        //在准备天空盒数据的时候，不需要准备纹理坐标，这个是因为天空盒本身的坐标其实就是纹理坐标，因为是从中心点向四周发散的方向向量
       function initCubeBuffer() {
           // 立方体数据
           //    v6----- v5
           //   /|           /|
           //  v1----- v0|
           //  | |           | |
           //  | |v7--   -|-|v4
           //  |/            |/
           //  v2------v3
           var vData = new Float32Array([
                10.0, 10.0, 10.0, -10.0, 10.0, 10.0, -10.0, -10.0, 10.0, 10.0, -10.0, 10.0,    // v0-v1-v2-v3 前
                10.0, 10.0, 10.0, 10.0, -10.0, 10.0, 10.0, -10.0, -10.0, 10.0, 10.0, -10.0,    // v0-v3-v4-v5 右
                10.0, 10.0, 10.0, 10.0, 10.0, -10.0, -10.0, 10.0, -10.0, -10.0, 10.0, 10.0,    // v0-v5-v6-v1 上
               -10.0, 10.0, 10.0, -10.0, 10.0, -10.0, -10.0, -10.0, -10.0, -10.0, -10.0, 10.0,    // v1-v6-v7-v2 左
               -10.0, -10.0, -10.0, 10.0, -10.0, -10.0, 10.0, -10.0, 10.0, -10.0, -10.0, 10.0,    // v7-v4-v3-v2 下
                10.0, -10.0, -10.0, -10.0, -10.0, -10.0, -10.0, 10.0, -10.0, 10.0, 10.0, -10.0     // v4-v7-v6-v5 后
           ]);
           //索引数据
           var iData = new Uint8Array([
               0, 1, 2, 0, 2, 3,     // 前
               4, 5, 6, 4, 6, 7,     // 右
               8, 9, 10, 8, 10, 11,    // 上
               12, 13, 14, 12, 14, 15,    // 左
               16, 17, 18, 16, 18, 19,    // 下
               20, 21, 22, 20, 22, 23     // 后
           ]);
           //法线数据
           var nData = new Float32Array([
               0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
               1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
               0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
               -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
               0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,  // v7-v4-v3-v2 down
               0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0   // v4-v7-v6-v5 back
           ]);
           var cData = new Float32Array([
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
           ]);
           var o = {};
           o.vBuffer = createBufferForLaterUse(gl, gl.ARRAY_BUFFER, vData);
           o.iBuffer = createBufferForLaterUse(gl, gl.ELEMENT_ARRAY_BUFFER, iData);
           o.nBuffer = createBufferForLaterUse(gl, gl.ARRAY_BUFFER, nData);
           o.cBuffer = createBufferForLaterUse(gl, gl.ARRAY_BUFFER, cData);
           o.indexCount = iData.length;
           return o;
       }

       function createBufferForLaterUse(gl, type, data) {
           var buffer = gl.createBuffer();
           gl.bindBuffer(type, buffer);
           gl.bufferData(type, data, gl.STATIC_DRAW);
           gl.bindBuffer(type, null);
           return buffer;
       }


       function loadImages(urls, callback) {
           var images = [];
           var i = 0;
           var _loop = function (url) {
               var img = new Image();
               img.onload = function () {
                   images.push(img);
                   if (images.length < urls.length) {
                       _loop(urls[++i]);
                   } else {
                       callback(images);
                   }
               };
               img.src = url;
           }
           _loop(urls[0]);
       }

       function initEventHandlers(canvas, currentAngle) {
           var dragging = false;         // Dragging or not
           var lastX = -1, lastY = -1;   // Last position of the mouse

           canvas.onmousedown = function (ev) {   // Mouse is pressed
               var x = ev.clientX, y = ev.clientY;
               // Start dragging if a moue is in <canvas>
               var rect = ev.target.getBoundingClientRect();
               if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
                   lastX = x; lastY = y;
                   dragging = true;
               }
           };

           canvas.onmouseup = function (ev) { dragging = false; }; // Mouse is released

           canvas.onmousemove = function (ev) { // Mouse is moved
               var x = ev.clientX, y = ev.clientY;
               if (dragging) {
                   var factor = 100 / canvas.height; // The rotation ratio
                   var dx = factor * (x - lastX);
                   //var dy = factor * (y - lastY);
                   var dy = 0;
                   //限制x方向的变化在-90到90度之间
                   currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
                   currentAngle[1] = currentAngle[1] + dx;
               }
               lastX = x, lastY = y;
           };
       }
    </script>
</head>
<body onload="main()">
    <div style="margin:0 auto;width:768px;height:768px">
        <canvas id="myCanvas" width="768" height="768">
            Please use a browser that supports "canvas"
        </canvas>
    </div>
    <div>
    </div>
</body>
</html>